
### 动态规划


```

1) 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。
   最优子结构性质为动态规划算法解决问题提供了重要线索。

2) 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

3) 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，
   每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。
   动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，
   然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，
   只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。



```

```

1) 寻找重叠子问题和最优子结构


2) 定义状态


3) 抽象状态转移方程

```

### 最小路径和问题

```

动态规划


        状态定义：

            dp[i][j] 表示移动到grid[i][j] 位置的最短路径和


        状态转移方程:


            1) 当前位置不在左边界，也不再上边界
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
            2) 当前位置在左边界
                dp[i][j] = dp[i][j-1] + grid[i][j]
            3) 当前位置在上边界:
                dp[i][j] = dp[i-1][j] + grid[i][j]
            4) 当前位置既在上边界，也在左边界
                dp[i][j] = grid[i][j]

        不需要建立 dp 矩阵浪费额外空间，直接遍历 grid[i][j]修改即可。这是因为：grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] ；
        原 grid 矩阵元素中被覆盖为dp元素后（都处于当前遍历点的左上方），不会再被使用到。


        时间复杂度: O(m * n) 遍历矩阵中的每个元素
        空间复杂度: O(1) 直接修改原矩阵，不使用额外空间。
        

```